<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Phillip Mates: Thoughts on testing in Clojure</title>
    

<meta property="og:url" content="https://philomates.github.io/articles/2022-03-16-thoughts-on-testing-in-clojure/" />
<meta property="og:title" content="Thoughts on testing in Clojure" />
<meta property="og:type" content="article" />

    <link rel="canonical" href="https://philomates.github.io/articles/2022-03-16-thoughts-on-testing-in-clojure/">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="//fonts.googleapis.com/css?family=Alegreya:400italic,700italic,400,700" rel="stylesheet"
          type="text/css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/default.min.css">
    <link href="/css/screen.css" rel="stylesheet" type="text/css" />
    <link rel="shortcut icon" href="favicon.ico">
</head>
<body>
    <header id="header"><div class="wrapper">
      <h1 id="title"><a href="/">Phillip Mates</a></h1>

      <ul id="navigation">
        <li><a href="/archives">Blog</a></li>
        <li><a href="/publications">Pubs</a></li>
      </ul>
    </div></header>

    
    <section id="main" class="wrapper">
<article>
  <h1>Thoughts on testing in Clojure</h1>

  <p class="date">March 16, 2022</p>


    <script src="../../js/clojure-mode.js" type="application/javascript"></script><h2 id="back-to-clojure">back to Clojure</h2><p>Last time around I wrote up my experiences hacking JavaScript VMs in C++. It was a fun and wild time; and to state the obvious: modern VMs, as well as C++, are damn complex beasts!</p><p>Since then though I've moved back to the Clojure world, joining the <a href="https://nextjournal.com/">Nextjournal</a> team where we're building tools for thought. Things like a reproducible notebook platform (<a href="https://nextjournal.com/">Nextjournal</a> itself) and local-first Clojure notebook tool (<a href="https://github.com/nextjournal/clerk">Clerk</a>).</p><p>So today I wanted to talk a bit about some fun I had with Clojure recently.
It has to do with test tooling, and I'll start with some background experiences and then share some code that I think demonstrates some compelling aspects of Clojure.</p><h2 id="background-experience-with-test-tools-in-clojure">background experience with test tools in Clojure</h2><p>Back when I worked at Nubank, I spent a good amount of time trying to improve the test tooling we had for Clojure.</p><p>When I joined, Nubank used <a href="https://github.com/marick/Midje/"><em>Midje</em></a> widely, which is a testing DSL inspired by Ruby's <a href="https://rspec.info/">RSpec</a>.
Coming from Java, I found <em>Midje</em> wonderfully expressive and capable but after some time realized that the DSL deviates from a few standards found in the Clojure ecosystem:</p><ul><li>loading a namespace is effectful, as in, it would execute the tests. This got in the way of some REPL-driven workflows, as well as analysis tooling.</li><li>assertions are described in a non-S-expression infix style <code>(fact (inc 1) =&gt; 2 (dec 1) =&gt; 0)</code>. This made it hard to use structural editing tools.</li><li>the library takes a strong "all or nothing" approach, where most Clojure libraries are small and composable.</li></ul><p>I hacked on <em>Midje</em> a bit trying to fix some things but eventually came to the opinion that if we wanted to evolve and improve our testing setup at Nubank, we should move to a collection of smaller and simpler tool.</p><p><em>clojure.test</em>, being more or less pervasive in the eco-system, seemed like a good thing to try.
I found it a hard swallow when used in isolation: it was very bare-bones when compared to what <em>Midje</em> was capable of.
But <em>clojure.test</em> was small and extensible, and with some work it looked promising to port the best ideas from <em>Midje</em> into a suite of smaller test-framework agnostic libraries to use with <em>clojure.test</em>.</p><p>We ended up with <em>clojure.test</em> at the core, <a href="https://github.com/nubank/matcher-combinators"><em>matcher-combinators</em></a> for asserting over nested data-structures in a declarative way, and <a href="https://github.com/nubank/mockfn"><em>mockfn</em></a> for mocking.</p><h2 id="tests-should-produce-data">tests should produce data</h2><p>In this time I often collaborated with <a href="https://github.com/sovelten">Sophia Velten</a>, who designed <a href="https://github.com/nubank/state-flow"><em>state-flow</em></a>, the library Nubank uses for single-service integration tests.</p><p>One thing Sophia emphasized with <em>state-flow</em> is that the result of running a test should be data.
It sounds like a simple and perhaps boring idea, but it has huge implications on the extensibility of a test framework.</p><p>For example, when <em>clojure.test</em> tests are run, they emit detailed human-readable reports and return very coarse-grained summary as data <code>{:test 7, :pass 25, :fail 0, :error 0, :type :summary}</code>.
This creates additional burden to tool makers that might want to adapt this output.
For instance, <a href="https://twitter.com/plexus">Arne Brasseur</a> details a bit in <a href="https://github.com/nubank/state-flow/issues/66#issuecomment-576801166">this github comment</a> how they handled this in the <a href="https://github.com/lambdaisland/kaocha"><em>Kaocha</em> test runner</a>.</p><p>This isn't unworkable with <em>clojure.test</em>, given that it uses multimethods for its reporting, which one can override with custom reporting logic.</p><p>But I guess the issue is that for tool builders it still requires a good bit of work, work that I imagine has been repeated many times by different people in different dev tool code.</p><p>To concretize my point, <em>clojure.test</em> currently works like this</p><div id="decouple"></div><script>nextjournal.clojure_mode.demo.render("decouple", `(require '[clojure.test :refer [deftest is testing]])

(deftest example-test
  (testing "this will fail"
    (is (= 1 2))))

;; running is coupled with reporting
(clojure.test/run-test-var #'example-test)
;; =>
;; FAIL in (example-test) (NO_SOURCE_FILE:74)
;; this will fail
;; expected: (= 1 2)
;;   actual: (not (= 1 2))
{:test 1, :pass 0, :fail 1, :error 0, :type :summary}`)</script><br />
And if test evaluation and reporting were decoupled, it could look like the following, which would give nice hooks for those working on dev tooling
<br /><br /><div id="as-data"></div><script>nextjournal.clojure_mode.demo.render("as-data", `(defn evaluate-test-var [test-var] 
  ...)

;; such that
(evaluate-test-var #'example-test)
;; =>
{#'scratch/example-test
 [{:file "NO_SOURCE_FILE"
   :line 74
   :type :fail
   :expected (= 1 2)
   :actual (not (= 1 2))
   :message nil,
   :context-str ("this will fail")}]}

(defn report! [report-data] 
  ...)

;; such that clojure.test/run-test-var could be defined as:
(def clojure.test/run-test-var (comp report! evaluate-test-var))`)</script><br /><h2 id="clerk--testing">Clerk + Testing?</h2><p>Okay, but why am I rambling about this at all?</p><p>Well, my colleagues at Nextjournal have been making some <a href="https://nextjournal.github.io/clerk-demo/">really</a> <a href="https://twitter.com/mkvlr/status/1503767871620538375">cool</a> <a href="https://twitter.com/mkvlr/status/1499470357262127106">stuff</a> with this local-first notebook tool called <em>Clerk</em>. They've taken to chatting me up about how <em>Clerk</em> could be applied to testing dev experience.</p><p>Like imagine being able to do your dev in Emacs or Neovim, but have a test runner that printed <em>matcher-combinator</em> mismatch test failures, where irrelevant parts of the data-structure were auto-folded away, or stack-traces with folding.</p><p>Or you could add tests to your notebooks, plus a button to run them, and see highlighting for assertion forms that pass or fail.</p><p>Anyways, I sat down to see how I could get <em>clojure.test</em> to provide test result data to then send over to custom <em>Clerk</em> viewers.</p><h2 id="separating-test-execution-from-test-reporting">separating test execution from test reporting</h2><p>As I dove into trying to get <em>clojure.test</em> data I realized there were no APIs for providing fine-grained report results. Like getting, as data, exactly which assertion forms failed and what <code>deftest</code> variables they are associated with doesn't seem possible.</p><p>So I found myself needing to solve the issue of decoupling test execution from test reporting, the thing that Sophia was so spot on about in <em>state-flow</em>'s design.</p><p>I hacked a bit and my solution and it turned out pretty cute, so I wanted to share it.</p><div id="editor"></div><script>nextjournal.clojure_mode.demo.render("editor", `(require '[clojure.test :as t])

;; grab the old clojure.test reporting multimethod implementations
(defonce test-report-methods (methods t/report))

(def ^:dynamic *test-results* nil)

(defn- register-test-result! [m]
  (when *test-results*
    (when-let [test-var (last t/*testing-vars*)]
      (dosync
        (commute *test-results*
                 update
                 test-var
                 (fnil conj [])
                 (assoc m :context-str t/*testing-contexts*))))))

;; redef reporting to store result map & dispatch to old definition
(defmethod t/report :pass [m]
  (register-test-result! m)
  ((get test-report-methods :pass) m))

(defmethod t/report :fail [m]
  (register-test-result! m)
  ((get test-report-methods :fail) m))

(defmethod t/report :error [m]
  (register-test-result! m)
  ((get test-report-methods :error) m))

;; running is decoupled into eval and report
(defn evaluate-test-var [test-var]
  (binding [*test-results* (ref {})
            t/*test-out* (new java.io.StringWriter)]
    (t/test-vars [test-var])
    @*test-results*))

(defn report! [report-data]
  (run! (fn [[test-var results]]
          (run! #(binding [t/*testing-contexts* (:context-str %)
                           t/*testing-vars* [test-var]]
                   ((get test-report-methods (:type %)) %))
                results))
        report-data))

;; now let's use it
(def my-run-test-var (comp report! evaluate-test-var))

(my-run-test-var #'example-test)
;; which is equivalent to clojure.test/run-test-var:
(t/run-test-var #'example-test)`);
</script><br /><p>What is going on here?
Well, <em>clojure.test</em> reporting is done using Clojure's multimethods, which allow you to dispatch to different function bodies depending on some dispatch criteria defined by <code>defmulti</code>. For instance, <code>clojure.test/report</code> looks like <code>(defmulti report :type)</code>, so the <code>:type</code> data of the arg passed into <code>report</code> specifies the behavior.</p><p>Multimethods are a nice way to bake extensibility into your libraries because one can always define a new multimethod dispatch/body.</p><p>For example, in the <em>matcher-combinators</em> integration with <em>clojure.test</em>, we were able to display custom <em>matcher-combinators</em> mismatch results by extending <code>clojure.test/report</code> in the <em>matcher-combinators</em> library itself, allowing operation over <code>:mismatch</code>, a new test result type we created (it <a href="https://github.com/nubank/matcher-combinators/pull/49/files#diff-c7340dd400d00da94964e2a1113886bd367b364028e0bdebdd9dc09e7f390a81L50">looked like this</a> but was eventually migrated)</p><p>What I'm doing now with the <code>report</code> multimethods above is stashing the old versions with <a href="https://clojuredocs.org/clojure.core/methods"><code>methods</code></a> (which I was delighted to discover this existed today), and redifining them to new behavior that eventually dispatches back to the stashed original. Essentially a hacky "call super"; using it ensures that the old <em>clojure.test</em> API continues to work fine. The new versions also accumulate some report data using same weird <code>binding</code>, <code>dosync</code>, <code>commute</code> stuff; a pattern I lift from the <em>clojure.test</em> code itself.</p><p>With the <code>report</code> definitions hijacked, we can implement <code>evaluate-test-var</code> to mute any results printed by <em>clojure.test</em> and also return the accumulated report data.</p><p>The new <code>report!</code> functionality then iterates through the report data produced by <code>evaluate-test-var</code> and calls the original <em>clojure.test</em> report functions (those that we stashed using <code>methods</code>) on the data.</p><p>You can try it out in your own REPL; you should see something like this:</p><div id="results"></div><script>nextjournal.clojure_mode.demo.render("results", `(evaluate-test-var #'example-test)
;; =>
{#'scratch/example-test
 [{:file "NO_SOURCE_FILE",
   :line 74,
   :type :fail,
   :expected (= 1 2),
   :actual (not (= 1 2)),
   :message nil,
   :context-str ("this will fail")}]}

((comp report! evaluate-test-var) #'example-test)
;; =>
;; FAIL in (example-test) (NO_SOURCE_FILE:74)
;; this will fail
;; expected: (= 1 2)
;;   actual: (not (= 1 2))`);
</script><br /><p>Cute, no? And fun how Clojure provides all the tools needed to do such adaptations to <em>clojure.test</em>. Sometimes at Nubank we'd toss around the idea of writing our own test framework with this decoupling baked it. But after this snippet of code I'm wondering if adapting is sufficient.</p>
</article>
</section>

<footer id="footer" class="wrapper">
</footer>



<script src="/js/highlight.pack.js" type="application/javascript"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
